// Autogenerated code!
// DO NOT EDIT!
//
// Generated by OrderedMap generator from the internal/cmd/generator command.

package catalog

import (
	"bytes"
	"encoding/json"
)

// Set sets a value with specified key.
func (m *HttpInteractions) Set(k HttpInteractionId, v *HttpInteraction) {
	m.mx.Lock()
	defer m.mx.Unlock()

	if m.data == nil {
		m.data = map[HttpInteractionId]*HttpInteraction{}
	}
	if !m.has(k) {
		m.order = append(m.order, k)
	}
	m.data[k] = v
}

// SetToTop do the same as Set, but new key will be placed on top of the order
// map.
func (m *HttpInteractions) SetToTop(k HttpInteractionId, v *HttpInteraction) {
	m.mx.Lock()
	defer m.mx.Unlock()

	if m.data == nil {
		m.data = map[HttpInteractionId]*HttpInteraction{}
	}
	if !m.has(k) {
		m.order = append([]HttpInteractionId{k}, m.order...)
	}
	m.data[k] = v
}

// Update updates a value with specified key.
func (m *HttpInteractions) Update(k HttpInteractionId, fn func(v *HttpInteraction) *HttpInteraction) {
	m.mx.Lock()
	defer m.mx.Unlock()

	if !m.has(k) {
		// Prevent from possible nil pointer dereference if map value type is a
		// pointer.
		return
	}

	m.data[k] = fn(m.data[k])
}

// GetValue gets a value by key.
func (m *HttpInteractions) GetValue(k HttpInteractionId) *HttpInteraction {
	m.mx.RLock()
	defer m.mx.RUnlock()

	return m.data[k]
}

// Get gets a value by key.
func (m *HttpInteractions) Get(k HttpInteractionId) (*HttpInteraction, bool) {
	m.mx.RLock()
	defer m.mx.RUnlock()

	v, ok := m.data[k]
	return v, ok
}

// Has checks that specified key is set.
func (m *HttpInteractions) Has(k HttpInteractionId) bool {
	m.mx.RLock()
	defer m.mx.RUnlock()

	return m.has(k)
}

func (m *HttpInteractions) has(k HttpInteractionId) bool {
	_, ok := m.data[k]
	return ok
}

// Len returns count of values.
func (m *HttpInteractions) Len() int {
	m.mx.RLock()
	defer m.mx.RUnlock()

	return len(m.data)
}

// Find finds first matched item from the map.
func (m *HttpInteractions) Find(fn findHttpInteractionsFunc) (HttpInteractionsItem, bool) {
	m.mx.RLock()
	defer m.mx.RUnlock()

	for _, k := range m.order {
		if fn(k, m.data[k]) {
			return HttpInteractionsItem{
				Key:   k,
				Value: m.data[k],
			}, true
		}
	}
	return HttpInteractionsItem{}, false
}

type findHttpInteractionsFunc = func(k HttpInteractionId, v *HttpInteraction) bool

// Each iterates and perform given function on each item in the map.
func (m *HttpInteractions) Each(fn eachHttpInteractionsFunc) error {
	m.mx.RLock()
	defer m.mx.RUnlock()

	for _, k := range m.order {
		if err := fn(k, m.data[k]); err != nil {
			return err
		}
	}
	return nil
}

// EachReverse act almost the same as Each but in reverse order.
func (m *HttpInteractions) EachReverse(fn eachHttpInteractionsFunc) error {
	m.mx.RLock()
	defer m.mx.RUnlock()

	for i := len(m.order) - 1; i >= 0; i-- {
		k := m.order[i]
		if err := fn(k, m.data[k]); err != nil {
			return err
		}
	}
	return nil
}

type eachHttpInteractionsFunc = func(k HttpInteractionId, v *HttpInteraction) error

func (m *HttpInteractions) EachSafe(fn eachSafeHttpInteractionsFunc) {
	m.mx.RLock()
	defer m.mx.RUnlock()

	for _, k := range m.order {
		fn(k, m.data[k])
	}
}

type eachSafeHttpInteractionsFunc = func(k HttpInteractionId, v *HttpInteraction)

// Map iterates and changes values in the map.
func (m *HttpInteractions) Map(fn mapHttpInteractionsFunc) error {
	m.mx.Lock()
	defer m.mx.Unlock()

	for _, k := range m.order {
		v, err := fn(k, m.data[k])
		if err != nil {
			return err
		}
		m.data[k] = v
	}
	return nil
}

type mapHttpInteractionsFunc = func(k HttpInteractionId, v *HttpInteraction) (*HttpInteraction, error)

// HttpInteractionsItem represent single data from the HttpInteractions.
type HttpInteractionsItem struct {
	Key   HttpInteractionId
	Value *HttpInteraction
}

var _ json.Marshaler = &HttpInteractions{}

func (m *HttpInteractions) MarshalJSON() ([]byte, error) {
	m.mx.RLock()
	defer m.mx.RUnlock()

	var buf bytes.Buffer
	buf.WriteRune('{')

	for i, k := range m.order {
		if i != 0 {
			buf.WriteRune(',')
		}

		// marshal key
		key, err := json.Marshal(k)
		if err != nil {
			return nil, err
		}
		buf.Write(key)
		buf.WriteRune(':')

		// marshal value
		val, err := json.Marshal(m.data[k])
		if err != nil {
			return nil, err
		}
		buf.Write(val)
	}

	buf.WriteRune('}')
	return buf.Bytes(), nil
}
